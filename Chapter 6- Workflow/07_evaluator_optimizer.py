# Generate a compelling product details for a product. Create it and then use an evaluator to analysis and review the output 
# It takes in name of product, features and target audience and use it to build the product details.
# The product details is generated by the Generator/optimizer node and then an evaluator node judges the output by the generator/optizer node. 
from langchain_openai import ChatOpenAI
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.graph import StateGraph, START, END
from typing import TypedDict, List, Literal
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()

class OptimizationState(TypedDict):
    product_name: str 
    product_features: List[str]
    target_audience: str 
    current_description: str 
    evaluation_result: dict 
    feedback: str 
    iteration_count: int 
    max_iterations: int 
    is_approved: bool 
    iteration_history: List[str]

#schema for structured output 1. for generator/optimzer node 2. evaluator

#schema for generator/optimizer
class ProductDescription(BaseModel):
    headlines: str = Field(description="Catchy headline (max 10 words)")
    description:str = Field(description="Main product description (100-150 words)")
    key_benefits: List[str] = Field(description="3-5 key benefits as bullet points")
    call_to_action: str = Field(description="Compelling call-to-action")

#Evaluation schema 
class Evaluation(BaseModel):
    overall_score: int = Field(description="Overall score  1-10", ge=1, le=10)
    clarity_score: int = Field(description="Clarity score 1-10 ", ge=1, le=10)
    persuasiveness_score: int = Field(description="Persuasiveness score 1-10 ", ge=1, le=10)
    audience_fit_score: int = Field(description="Target audience fit  1-10 ", ge=1, le=10)
    is_approved: int = Field(description="Whether description meets standards (score >= 8)")
    strengths: List[str] = Field(description="What works well")
    weaknesses: List[str] = Field(description="What needs improvement")
    specific_feedback: List[str] = Field(description="Detailed, actionable feedback for revision")

llm = ChatOpenAI(model="gpt-4o-mini")

gemini_llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash-lite")

# Generator/Optimzer
def generator_description(state: OptimizationState)->OptimizationState:
    iteration = state['iteration_count']

    print(f"\n"+ "="*70)
    print(f"OPTIMIZER Iteration: {iteration}")
    print(f"\n"+ "="*70)


    optimizer_llm = llm.with_structured_output(ProductDescription)

    if iteration ==1:
        print("Creating Initial product description....")

        prompt = f"""
        Create a compelling product description for:

        Product: {state['product_name']}
        Feature: {', '.join(state['product_features'])}
        Target Audience: {state['target_audience']}

        Requirements:
        - Headlines: Catchy and concise (max 10 words)
        - Description: Engaging and informative (100-150 words)
        - Key Benefits: 3-5 clear, Compleiing benefits
        - Call-to-Action: Strong, action-oriented CTA

        Make it persuasive and tailored to the target audience
        """
    else:
        print("Refining Description based on evaluation Feedback...")

        prompt = f""" 
            Improve this product description based on feedback:

            Product: {state['product_name']}
            Target Audience: {state['target_audience']}

            Current Description:
            {state['current_description']}

            EVALUATION SCORES:
            - Overall: {state['evaluation_result'].get('overall_score',0)}/10
            - Clarity: {state['evaluation_result'].get('clarity_score',0)}/10
            - Persuasiveness: {state['evaluation_result'].get('persuasiveness_score',0)}/10
            - Audience Fit: {state['evaluation_result'].get('audience_fit_score',0)}/10

            FEEDBACK TO ADDRESS:
            {state['feedback']}

            CRITICAL: Focus on the specific weakness mentioned. Make targeted improvement to:
            1. Address each point in the feedback
            2. Maintain the strengths that were working
            3. Increase scores in weak areas

            Generate an improved version that addresses all fedback.
        """

    description = optimizer_llm.invoke(prompt)

    formatted_description =  f""" 
    HEADLINE: {description.headlines}

    DESCRIPTION:
    {description.description}

    KEY BENEFITS:
    {chr(10).join( [ f"& {benefit} "for benefit in description.key_benefits])}

    CALL TO ACTION:
    {description.call_to_action}

    """

    print("GEneration Description")
    print("="*70)
    print(formatted_description + "\n")

    return {
        "current_description": formatted_description,
        "iteration_count": iteration + 1
    }


#Evaluator Node 
def evaulate_description(state:OptimizationState)-> OptimizationState:
    print(f"\n"+ "="*70)
    print(f"EVALUATOR: REviewing Description")
    print(f"\n"+ "="*70)

    evaluator_llm = gemini_llm.with_structured_output(Evaluation)

    prompt = f"""
    Evaulate this product description objectively:

    Product: {state['product_name']}
    Target Audience: {state['target_audience']}

    DESCRIPTION TO EVALUATE:
    {state['current_description']}

    Evaluate on these criteria (1-10 scale):
    1. CLARITY: Is it clear and easy to understand?
    2. PERSUASIVENESS: Does it effectively sell the product?
    3. AUDIENCE FIT: Does it resonate with the target audience?

    APPROVAL CRITERIAL: OVerall score must be 8 or higher to approve

    Provide:
    - Scores for each criterion
    - Overall score (average of criteria)
    - Whether it's approved (score >= 8 )
    - Specific stregth (what's working well)
    - Specific weaknesses (what needs improvement)
    - Specific feedback for the next iteration

    Be objective and constructive.
    """

    evaluation =  evaluator_llm.invoke(prompt)

    print(f"Evaluation Results")
    print("-"*70)

    print(f"Overall Score: {evaluation.overall_score}/10")
    print(f"Overall Score: {evaluation.overall_score}/10")
    print(f"Persuasiveness: {evaluation.persuasiveness_score}/10")
    print(f"Audience Fit: {evaluation.audience_fit_score}/10")
    print(f"STATUS: {'APPROVED' if evaluation.is_approved else 'NEEDS REVISION'}")
    print(f"\nStrength")

    for strength in evaluation.strengths:
        print(f"- {strength}")

    for weakness in evaluation.weaknesses:
        print(f"- {weakness}")

    print(f"\nFeedback: {evaluation.specific_feedback}")

    iteration_record = {
        "iteration": state["iteration_count"],
        "description": state['current_description'],
        "sources":{
            "overall": evaluation.overall_score,
            "clarity": evaluation.clarity_score,
            "persuasiveness": evaluation.persuasiveness_score,
            "audience_fit": evaluation.audience_fit_score

        },
        "approved": evaluation.is_approved,
        "feedback": evaluation.specific_feedback

    }

    history = state.get("iteration_history",[])
    history.append(iteration_record)

    return {
        "evaluation_result": evaluation.model_dump(),
        "feedback": evaluation.specific_feedback,
        "is_approved": evaluation.is_approved,
        "iteration_history": history
    }


# Decision Function

def should_continue(state:OptimizationState)->Literal["Optimizer","end"]:
    if state['is_approved']:
        print(F"\n SUCCESS: Description Approved")
        return "end"
    
    if state['iteration_count'] > state['max_iterations']:
        print (f"\n MAX ITERATION REACHED: Stopping at iteration {state['iteration_count'] - 1}")

        return "Optimizer" 
    
# build the graph
builder = StateGraph(OptimizationState)

builder.add_node("optimizer", generator_description)
builder.add_node("evaluator", evaulate_description)

builder.add_edge(START, "optimizer")
builder.add_edge("optimizer","evaluator")

builder.add_conditional_edges(
    "evaluator",
    should_continue,
    {
        "optimizer":"optimizer",
        "end": END
    }
)

graph = builder.compile()

print("="*70)
print("EVALUATOR-OPTIIZER PATTERN: PRODUCT DESCRIPTION")
print("="*70)
print("Example: Fitness Tracker")
print("="*70)

result = graph.invoke({
    "product_name":"Fitpulse Pro Smart watch",
    "product_features":[
        "Heart rate monitoring",
        "GPS tracking",
        "Sleep Analysis",
        "Waterproof to 50m",
        "7-day battery life",
        "Smartphone notification"
    ],
    "target_audience": "Health-concious professionals age 25-45",
    "current_description":"",
    "evaluation_result":{},
    "feedback": "",
    "iteration_count": 1,
    "max_iterations": 5,
    "is_approved": False,
    "iteration_history":[]
})

print("="*70)
print("FINAL APPROVED DESCRIPTION")
print("="*70)
print(result['current_description'])
